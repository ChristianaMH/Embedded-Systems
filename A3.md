**Problem Description**

For this assignment we are using port 1 pin 2 to get the analog signal input from the potentiometer and then convert that into digital signal. This digital signal will be seen in an output on the LED on a breadboard which is connected to port 3 pin 0 on the microcontroller. We controlled the frequency of the analog input using the potentiometer and that can be seen in the blinking frequency of the LED. 


**Pseudocode**

; Typical Initialization as follows:

	; Include device header file
 
   	INCLUDE "msp430.h"
    
	; Define and export program entry-point to linker
 
	EXPORT RESET
 
	; Assemble into program memory and retain current section
 
	TEXT
 
	RETAIN
 
	RETAINREFS
 
RESET:
	;Initialize stack pointer
 
	SET SP TO __STACK_END
 
	StopWDT:
 
	;Stop watchdog timer
 
	SET WDTCTL TO WDTPW | WDTHOLD
 
;Typically template assembly initialization ends
 
Main Loop Begins Here:

	init:

	;Clear Port 3 for output 
 
 	clr.b P3OUT
  
	;Clear Register R4 
 
 	clr.w R4
  
	;Set P3 in the output direction by setting all the bits to 1 
 
 	mov.w #0FFh, &P3DIR
  
	;Set Port1 Pin2 to get be an ADC input channel using selection bits 
 
 	bis.b #BIT2, &P1SEL0 bis.b #BIT2, &P1SEL1
  
	;Disable low power mode (“unlocks” the microcontroller so all the pins work)
 
 	CLEAR PM5CTL0 LOCKLPM5
  
	;Start setting up ADC
 
	;Enable ADC and set ADC cycles to 16 
 
 	mov.w #0210h, &ADCCTL0
  
	;Select clock source as ACLK and divide by 1 
 
 	mov.w #0220h, &ADCCTL1
  
	;Set resolution bit to 12-bit resolution 
 
 	mov.w #0020h, &ADCCTL2
  
	;Set voltage reference to A2 channel 
 
 	mov.w #0002h, &ADCMCTL0
  
	;Enable individual ADC interrupt for ADCMEM0 
 
 	bis.w #ADCIE0, &ADCIE
  
	;Add a nop because it's good practice 
 
 	nop
  
	;Enable global interrupt 
 
 	bis.w #GIE, SR
  
	;Add a nop because it's good practice 
 
 	nop
 
Start setting up the timer
Clear Timer control register ;bis.w #TBCLR, &TB0CTL
Set timer source to ACLK ;bis.w #TBSSEL__ACLK, &TB0CTL
Set timer value to one second which is 0x8000 ;mov.w #8000h, &TB0CCR0
Set timer mode to count up ;bis.w #MC__UP, &TB0CTL
Enable timer interrupt on overflow ;bis.w #TBIE, &TB0CT
Clear timer flag ;bic.w #TBIFG, &TB0CTL
Add a nop because it's good practice ;nop
 
Start the ADC conversion ;mov.w #0213h, &ADCCTL0
 
main:
jump to main and continue doing so until there is an overflow ;jmp main
Add a nop because it's good practice ;nop
 
Interrupt service routine for ADC ;ISR_ADC:
Move the conversion result to R4 ;mov.w ADCMEM0, R4
Increase R4 to see the change in LED with human eye ;add.w #0FFFFh, R4
Set timer reset value to R4 ;mov.w R4, &TB0CCR0          	
Start ADC conversion again ;;mov.w #0213h, &ADCCTL0
Return from interrupt          	;reti
 
Interrupt service routine for timer ;ISR_TB0:
Toggle LED on P3 output using xor as to get a delay ;xor.b #BIT0, &P3OUT
Clear the timer interrupt flag ;bic.w #TBIFG, &TB0CTL
Return from interrupt          	;reti
 
; Typical stack definition and interrupt vector initialization below
STACK_POINTER_DEFINITION:
	; Define stack pointer
	GLOBAL __STACK_END
	SECTION .stack
INTERRUPT_VECTORS:
	; Define interrupt vectors
	SECTION .reset
	SHORT RESET
	SECTION .int42
	SHORT ISR_TB0
END
